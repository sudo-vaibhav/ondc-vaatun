---
phase: 02-core-instrumentation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - server/src/trpc/trpc.ts
autonomous: true

must_haves:
  truths:
    - "Every tRPC procedure call creates a span named trpc.{type}.{path}"
    - "Failed procedures record exception and set ERROR status on span"
    - "Span attributes include trpc.procedure and trpc.type"
    - "All 19 procedures (health, registry, gateway, results) are instrumented without per-router changes"
  artifacts:
    - path: "server/src/trpc/trpc.ts"
      provides: "tRPC tracing middleware applied to publicProcedure"
      contains: "tracingMiddleware"
      exports: ["publicProcedure", "router"]
  key_links:
    - from: "server/src/trpc/trpc.ts"
      to: "@opentelemetry/api"
      via: "import { trace, SpanStatusCode }"
      pattern: "trace\\.getTracer"
    - from: "server/src/trpc/trpc.ts"
      to: "all tRPC routers"
      via: "publicProcedure export with middleware chain"
      pattern: "t\\.procedure\\.use\\(tracingMiddleware\\)"
---

<objective>
Add OpenTelemetry tracing middleware to tRPC's `publicProcedure` so every procedure call is wrapped in a span.

Purpose: This is the foundation for the span hierarchy (HTTP request -> tRPC procedure -> ONDC action -> HTTP client). All 19 tRPC procedures will automatically get spans without per-router changes.

Output: Modified `server/src/trpc/trpc.ts` with tracing middleware applied to `publicProcedure`.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-instrumentation/02-RESEARCH.md
@.planning/phases/02-core-instrumentation/CONTEXT.md
@server/src/trpc/trpc.ts
@server/src/tracing.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add tracing middleware to publicProcedure</name>
  <files>server/src/trpc/trpc.ts</files>
  <action>
Modify `server/src/trpc/trpc.ts` to add a tracing middleware that wraps all procedure calls in OpenTelemetry spans.

Current file contents (entire file):
```typescript
import { initTRPC } from "@trpc/server";
import type { Context } from "./context";

const t = initTRPC.context<Context>().create();

export const router = t.router;
export const publicProcedure = t.procedure;
```

Replace with:
```typescript
import { trace, SpanStatusCode } from "@opentelemetry/api";
import { initTRPC } from "@trpc/server";
import type { Context } from "./context";

const t = initTRPC.context<Context>().create();

const tracer = trace.getTracer("ondc-bap-trpc", "0.1.0");

const tracingMiddleware = t.middleware(async (opts) => {
  return tracer.startActiveSpan(
    `trpc.${opts.type}.${opts.path}`,
    async (span) => {
      try {
        span.setAttribute("trpc.procedure", opts.path);
        span.setAttribute("trpc.type", opts.type);

        const result = await opts.next();

        span.setStatus({ code: SpanStatusCode.OK });
        return result;
      } catch (error) {
        span.recordException(error as Error);
        span.setStatus({
          code: SpanStatusCode.ERROR,
          message: (error as Error).message,
        });
        throw error;
      } finally {
        span.end();
      }
    },
  );
});

export const router = t.router;
export const publicProcedure = t.procedure.use(tracingMiddleware);
```

Key design decisions:
- Use `startActiveSpan` (NOT `startSpan`) so child spans in procedures automatically nest under this span via AsyncLocalStorage context propagation.
- Span name format: `trpc.{type}.{path}` (e.g., `trpc.mutation.gateway.search`, `trpc.query.health.check`).
- Always call `span.end()` in `finally` block to prevent leaked spans on errors.
- Record exceptions with `span.recordException()` AND set ERROR status for proper error visualization in SigNoz.
- Return `opts.next()` result to preserve tRPC response chain.
- Tracer name `ondc-bap-trpc` with version `0.1.0` follows the multi-tracer convention from the research.
  </action>
  <verify>
Run `pnpm check` from the project root to verify TypeScript compilation and Biome linting pass. The @opentelemetry/api package is already installed from Phase 1 so imports will resolve.

Also verify that the export signature is unchanged: `publicProcedure` and `router` are still exported and all existing router files (gateway.ts, health.ts, registry.ts, results.ts) import from `../trpc` without changes needed.
  </verify>
  <done>
`server/src/trpc/trpc.ts` exports `publicProcedure` with tracing middleware applied. TypeScript compiles. All 18 procedures automatically get tracing spans without any per-router modifications.
  </done>
</task>

</tasks>

<verification>
1. `pnpm check` passes (TypeScript + Biome)
2. `server/src/trpc/trpc.ts` imports from `@opentelemetry/api`
3. `publicProcedure` is `t.procedure.use(tracingMiddleware)`
4. Span name uses `trpc.${opts.type}.${opts.path}` pattern
5. Error handling: `recordException` + `setStatus(ERROR)` + `throw`
6. `span.end()` in `finally` block
</verification>

<success_criteria>
- tRPC tracing middleware exists and is applied to publicProcedure
- All 19 existing procedures across 4 routers work without modification (they import publicProcedure which now includes middleware)
- TypeScript compiles without errors
- Span attributes include trpc.procedure and trpc.type
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-instrumentation/02-01-SUMMARY.md`
</output>
