---
phase: 02-core-instrumentation
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - server/src/trpc/routers/gateway.ts
autonomous: true

must_haves:
  truths:
    - "gateway.search procedure creates a child span labeled ondc.search"
    - "ondc.search span has attributes: ondc.transaction_id, ondc.message_id, ondc.action, ondc.domain, ondc.subscriber_id"
    - "The ondc.search span is a child of the tRPC middleware span (from 02-01)"
    - "The ONDCClient.send() span (from 02-03) appears as child of ondc.search span"
    - "transactionId and messageId are captured as span attributes before the ONDC HTTP call"
  artifacts:
    - path: "server/src/trpc/routers/gateway.ts"
      provides: "gateway.search procedure with ondc.search manual span"
      contains: "startActiveSpan"
  key_links:
    - from: "server/src/trpc/routers/gateway.ts"
      to: "@opentelemetry/api"
      via: "import { trace, SpanStatusCode }"
      pattern: "trace\\.getTracer"
    - from: "gateway.ts search procedure"
      to: "trpc.ts middleware span"
      via: "AsyncLocalStorage context (startActiveSpan nesting)"
      pattern: "tracer\\.startActiveSpan.*ondc\\.search"
    - from: "gateway.ts search procedure"
      to: "ONDCClient.send() span"
      via: "ondcClient.send() call inside ondc.search span callback"
      pattern: "ondcClient\\.send.*inside.*startActiveSpan"
---

<objective>
Add a manual OpenTelemetry span to the `gateway.search` procedure that captures ONDC-specific attributes (transactionId, messageId, action, domain, subscriber_id).

Purpose: This creates the middle layer of the span hierarchy: HTTP request -> tRPC procedure -> **ONDC action** -> HTTP client. The search procedure is the prototype for Phase 4 which will extend this pattern to all gateway procedures (select, init, confirm, status).

Output: Modified `server/src/trpc/routers/gateway.ts` with `gateway.search` mutation body wrapped in `tracer.startActiveSpan("ondc.search", ...)`.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-instrumentation/02-RESEARCH.md
@.planning/phases/02-core-instrumentation/CONTEXT.md
@.planning/phases/02-core-instrumentation/02-01-SUMMARY.md
@server/src/trpc/routers/gateway.ts
@server/src/tracing.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ondc.search span to gateway.search procedure</name>
  <files>server/src/trpc/routers/gateway.ts</files>
  <action>
Modify `server/src/trpc/routers/gateway.ts` to add a manual span inside the `search` procedure mutation handler.

Add imports at the top of the file (after existing imports):
```typescript
import { trace, SpanStatusCode } from "@opentelemetry/api";
```

Add tracer instance after imports:
```typescript
const tracer = trace.getTracer("ondc-bap", "0.1.0");
```

Modify ONLY the `search` procedure's mutation callback. Wrap the entire mutation body in `tracer.startActiveSpan("ondc.search", ...)`. Do NOT modify any other procedure in this plan.

Current search mutation body (lines 21-49):
```typescript
.mutation(async ({ ctx, input }) => {
  const { tenant, ondcClient, kv } = ctx;
  const transactionId = uuidv7();
  const messageId = uuidv7();
  await createSearchEntry(kv, transactionId, messageId, input.categoryCode);
  const payload = createSearchPayload(tenant, transactionId, messageId, input.categoryCode);
  const gatewayUrl = new URL("search", tenant.gatewayUrl);
  console.log("[Search] Sending request to:", gatewayUrl.toString());
  console.log("[Search] Payload:", JSON.stringify(payload, null, "\t"));
  const response = await ondcClient.send(gatewayUrl, "POST", payload);
  console.log("[Search] ONDC Response:", JSON.stringify(response, null, 2));
  return { ...response, transactionId, messageId };
})
```

New search mutation body:
```typescript
.mutation(async ({ ctx, input }) => {
  const { tenant, ondcClient, kv } = ctx;

  return tracer.startActiveSpan("ondc.search", async (span) => {
    try {
      const transactionId = uuidv7();
      const messageId = uuidv7();

      // ONDC-specific attributes (CONTEXT.md decision 2: full ONDC set)
      span.setAttribute("ondc.transaction_id", transactionId);
      span.setAttribute("ondc.message_id", messageId);
      span.setAttribute("ondc.action", "search");
      span.setAttribute("ondc.domain", tenant.domainCode);
      span.setAttribute("ondc.subscriber_id", tenant.subscriberId);

      await createSearchEntry(kv, transactionId, messageId, input.categoryCode);

      const payload = createSearchPayload(
        tenant,
        transactionId,
        messageId,
        input.categoryCode,
      );
      const gatewayUrl = new URL("search", tenant.gatewayUrl);

      console.log("[Search] Sending request to:", gatewayUrl.toString());
      console.log("[Search] Payload:", JSON.stringify(payload, null, "\t"));

      // ondcClient.send() creates its own child span (ondc.http.request from 02-03)
      const response = await ondcClient.send(gatewayUrl, "POST", payload);

      console.log("[Search] ONDC Response:", JSON.stringify(response, null, 2));

      span.setStatus({ code: SpanStatusCode.OK });
      return {
        ...response,
        transactionId,
        messageId,
      };
    } catch (error) {
      span.recordException(error as Error);
      span.setStatus({
        code: SpanStatusCode.ERROR,
        message: (error as Error).message,
      });
      throw error;
    } finally {
      span.end();
    }
  });
})
```

Key design decisions:
- Use `startActiveSpan` so the ONDCClient.send() span (from Plan 03) automatically becomes a child of this span via AsyncLocalStorage.
- Set ONDC attributes immediately after generating IDs (before any async work) so they're captured even if the procedure fails mid-execution.
- `ondc.bpp_id` and `ondc.bpp_uri` are NOT set for search (search goes to gateway, not a specific BPP). These will be set in Phase 4 for select/init/confirm procedures.
- `span.end()` in `finally` block.
- All existing `console.log` calls preserved for backward compatibility.
- Do NOT add spans to any other procedures (select, init, confirm, status, onSearch, onSelect, etc.) -- those are Phase 4 scope.
  </action>
  <verify>
Run `pnpm check` from the project root to verify TypeScript compilation and Biome linting pass.

Verify the search procedure is the ONLY procedure modified. All other 11 gateway procedures should be untouched. Check by searching for `startActiveSpan` -- it should appear exactly once in gateway.ts (in the search mutation).
  </verify>
  <done>
`gateway.search` creates a child span "ondc.search" with ONDC-specific attributes (transaction_id, message_id, action, domain, subscriber_id). The span nests properly under the tRPC middleware span and above the ONDCClient HTTP span. TypeScript compiles. No other gateway procedures are modified.
  </done>
</task>

</tasks>

<verification>
1. `pnpm check` passes (TypeScript + Biome)
2. `server/src/trpc/routers/gateway.ts` imports from `@opentelemetry/api`
3. `tracer.startActiveSpan("ondc.search", ...)` wraps the search mutation body
4. Span attributes: `ondc.transaction_id`, `ondc.message_id`, `ondc.action`, `ondc.domain`, `ondc.subscriber_id`
5. `span.end()` in `finally` block
6. Only the `search` procedure is modified -- all other procedures unchanged
7. Existing console.log calls preserved
</verification>

<success_criteria>
- gateway.search creates an "ondc.search" child span with ONDC attributes
- transactionId and messageId captured as span attributes
- Span hierarchy: tRPC middleware (02-01) -> ondc.search (this plan) -> ondc.http.request (02-03)
- Only search procedure modified, all other gateway procedures untouched
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-instrumentation/02-02-SUMMARY.md`
</output>
