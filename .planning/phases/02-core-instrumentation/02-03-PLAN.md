---
phase: 02-core-instrumentation
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - server/src/lib/ondc/client.ts
autonomous: true

must_haves:
  truths:
    - "Every outgoing ONDC HTTP request creates a span named ondc.http.request"
    - "Span captures full request body as JSON string (subject to 16KB truncation from Phase 1)"
    - "Span captures complete Authorization header with no truncation"
    - "Span captures response status code and response body"
    - "Failed HTTP requests record exception and set ERROR status"
    - "sendWithAck delegates to send, inheriting all tracing behavior"
  artifacts:
    - path: "server/src/lib/ondc/client.ts"
      provides: "ONDCClient with OpenTelemetry manual spans in send()"
      contains: "startActiveSpan"
  key_links:
    - from: "server/src/lib/ondc/client.ts"
      to: "@opentelemetry/api"
      via: "import { trace, SpanStatusCode }"
      pattern: "trace\\.getTracer"
    - from: "server/src/lib/ondc/client.ts"
      to: "tRPC procedure spans (02-01)"
      via: "AsyncLocalStorage context propagation"
      pattern: "startActiveSpan.*ondc\\.http\\.request"
---

<objective>
Wrap ONDCClient.send() in an OpenTelemetry manual span that captures full request/response payloads, Authorization header, and HTTP metadata.

Purpose: This creates the deepest layer of the span hierarchy (HTTP request -> tRPC procedure -> ONDC action -> **HTTP client**). Every outgoing ONDC request will carry debugging data: URL, method, auth header, request body, response status, response body.

Output: Modified `server/src/lib/ondc/client.ts` with `send()` wrapped in `tracer.startActiveSpan()`.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-instrumentation/02-RESEARCH.md
@.planning/phases/02-core-instrumentation/CONTEXT.md
@server/src/lib/ondc/client.ts
@server/src/tracing.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add manual span to ONDCClient.send() with payload capture</name>
  <files>server/src/lib/ondc/client.ts</files>
  <action>
Modify `server/src/lib/ondc/client.ts` to wrap the `send()` method in a `tracer.startActiveSpan()` call that captures all request/response data.

Current `send()` method flow:
1. Create auth header
2. fetch(url, { method, headers, body })
3. Check response.ok, throw on error
4. Parse JSON, return data

New flow:
1. Start active span "ondc.http.request"
2. Create auth header -> set span attribute `http.request.header.authorization` (full, no truncation - CONTEXT.md decision 4)
3. Serialize body -> set span attributes `http.request.body` (JSON string, 16KB limit handled by Phase 1 SDK config) and `http.request.body.size` (integer bytes)
4. Set span attributes `http.url`, `http.method`
5. fetch(url, { method, headers, body })
6. Set span attribute `http.status_code`
7. On success: parse JSON, set `http.response.body`, set OK status, end span, return data
8. On error: set `http.response.body` (error text), record exception, set ERROR status, end span, throw
9. On any exception (network error etc): record exception, set ERROR status, end span, throw

Import additions at top of file:
```typescript
import { trace, SpanStatusCode } from "@opentelemetry/api";
```

Add tracer as class property:
```typescript
private tracer = trace.getTracer("ondc-bap-http", "0.1.0");
```

Replace the `send()` method body with a `startActiveSpan` wrapper. The complete new method:

```typescript
async send<T = unknown>(
  url: string | URL,
  method: "POST" | "GET",
  body: object,
): Promise<T> {
  return this.tracer.startActiveSpan("ondc.http.request", async (span) => {
    try {
      // HTTP metadata attributes
      span.setAttribute("http.url", url.toString());
      span.setAttribute("http.method", method);

      // Full request body capture (16KB limit enforced by SDK spanLimits)
      const bodyJson = JSON.stringify(body);
      span.setAttribute("http.request.body", bodyJson);
      span.setAttribute("http.request.body.size", bodyJson.length);

      // Authorization header - full capture, no truncation (CONTEXT.md decision 4)
      const authHeader = await this.createAuthorizationHeader(body);
      span.setAttribute("http.request.header.authorization", authHeader);

      const response = await fetch(url, {
        method,
        headers: {
          "Content-Type": "application/json",
          Authorization: authHeader,
        },
        body: bodyJson,
      });

      // Response metadata
      span.setAttribute("http.status_code", response.status);

      if (!response.ok) {
        const errorText = await response.text();
        span.setAttribute("http.response.body", errorText);
        throw new Error(
          `ONDC Request Failed [${response.status}]: ${errorText}`,
        );
      }

      const data = await response.json();
      span.setAttribute("http.response.body", JSON.stringify(data));

      span.setStatus({ code: SpanStatusCode.OK });
      return data as T;
    } catch (error) {
      span.recordException(error as Error);
      span.setStatus({
        code: SpanStatusCode.ERROR,
        message: (error as Error).message,
      });
      console.error(`[ONDCClient] Error sending to ${url}:`, error);
      throw error;
    } finally {
      span.end();
    }
  });
}
```

Key changes from the original:
- `body` is serialized ONCE into `bodyJson` and reused (was serialized inline in fetch call).
- Auth header is created before fetch and stored, so it can be set as span attribute before the fetch call.
- `span.end()` is in `finally` block (critical anti-pattern avoidance from research).
- The `console.error` logging is preserved from the original code.
- `sendWithAck()` is NOT modified -- it calls `this.send()` which already has tracing, so it inherits span behavior automatically.

Do NOT modify `createAuthorizationHeader()` or `sendWithAck()` methods.
  </action>
  <verify>
Run `pnpm check` from the project root to verify TypeScript compilation and Biome linting pass. The @opentelemetry/api package is already installed from Phase 1.

Verify that `sendWithAck()` still works by checking it delegates to `this.send()` unchanged.
  </verify>
  <done>
`ONDCClient.send()` creates a span "ondc.http.request" with full request body, Authorization header, URL, method, status code, and response body as span attributes. Errors are recorded with exception details. TypeScript compiles without errors.
  </done>
</task>

</tasks>

<verification>
1. `pnpm check` passes (TypeScript + Biome)
2. `server/src/lib/ondc/client.ts` imports from `@opentelemetry/api`
3. `send()` method body is wrapped in `this.tracer.startActiveSpan()`
4. Span name is `ondc.http.request`
5. Attributes set: `http.url`, `http.method`, `http.request.body`, `http.request.body.size`, `http.request.header.authorization`, `http.status_code`, `http.response.body`
6. `span.end()` in `finally` block
7. `sendWithAck()` unchanged (inherits tracing from `send()`)
8. Body serialized once and reused
</verification>

<success_criteria>
- ONDCClient.send() wraps all fetch calls in OpenTelemetry spans
- Full Authorization header captured as-is without truncation (CONTEXT.md decision 4)
- Request body captured as JSON string
- Response body captured for both success and error cases
- Error paths record exceptions and set ERROR status
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-instrumentation/02-03-SUMMARY.md`
</output>
