---
phase: 04-confirm-status
plan: 03
type: execute
wave: 2
depends_on: ["04-01", "04-02"]
files_modified:
  - client/src/routes/payment-callback/$transactionId.tsx
  - client/src/lib/confirm-data.ts
  - client/src/routes/init/$transactionId/$messageId.tsx
autonomous: true

must_haves:
  truths:
    - "Payment callback page triggers confirm request on mount"
    - "Confirm data persists across BPP payment redirect"
    - "Status polling stops on PAID or 2 minute timeout"
    - "User redirected to policy-success page when payment confirmed"
    - "NOT-PAID status shows helpful instructions"
  artifacts:
    - path: "client/src/routes/payment-callback/$transactionId.tsx"
      provides: "Payment return handling page"
      min_lines: 100
    - path: "client/src/lib/confirm-data.ts"
      provides: "localStorage persistence for confirm data"
      exports: ["storeConfirmData", "getConfirmData", "clearConfirmData", "ConfirmData"]
  key_links:
    - from: "payment-callback/$transactionId.tsx"
      to: "/api/trpc/gateway.confirm"
      via: "trpc.gateway.confirm.useMutation"
      pattern: "trpc\\.gateway\\.confirm"
    - from: "payment-callback/$transactionId.tsx"
      to: "/api/trpc/results.getStatusResults"
      via: "trpc.results.getStatusResults.useQuery"
      pattern: "trpc\\.results\\.getStatusResults"
    - from: "init polling page"
      to: "confirm-data.ts"
      via: "storeConfirmData before payment redirect"
      pattern: "storeConfirmData"
---

<objective>
Create payment callback page that handles BPP return, triggers confirm, polls status, and redirects to success.

Purpose: Complete the payment flow by handling user return from BPP payment gateway, confirming the transaction, and polling for policy issuance.

Output: Payment callback route, confirm data persistence utility, and init page update to store data before redirect.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-confirm-status/04-CONTEXT.md
@.planning/phases/04-confirm-status/04-RESEARCH.md

# Pattern reference - init polling page structure
@client/src/routes/init/$transactionId/$messageId.tsx
@client/src/routes/quote/$transactionId/$messageId.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create confirm data persistence utility</name>
  <files>client/src/lib/confirm-data.ts</files>
  <action>
Create client/src/lib/confirm-data.ts for persisting confirm data across payment redirect:

```typescript
/**
 * Confirm Data Persistence
 *
 * Stores data needed for confirm request in localStorage before
 * user is redirected to BPP payment gateway. Retrieved on payment callback.
 */

export interface ConfirmData {
  transactionId: string;
  bppId: string;
  bppUri: string;
  providerId: string;
  itemId: string;
  parentItemId: string;
  xinputFormId: string;
  submissionId: string;
  addOns?: Array<{ id: string; quantity: number }>;
  customerName: string;
  customerEmail: string;
  customerPhone: string;
  quoteId: string;
  amount: string;
  quoteBreakup?: Array<{ title: string; price: { currency: string; value: string } }>;
  // Store timestamp to detect stale data
  storedAt: number;
}

const STORAGE_KEY = "ondc_confirm_data";
const MAX_AGE_MS = 30 * 60 * 1000; // 30 minutes

export function storeConfirmData(data: Omit<ConfirmData, "storedAt">): void {
  const withTimestamp: ConfirmData = {
    ...data,
    storedAt: Date.now(),
  };
  localStorage.setItem(STORAGE_KEY, JSON.stringify(withTimestamp));
}

export function getConfirmData(transactionId: string): ConfirmData | null {
  const stored = localStorage.getItem(STORAGE_KEY);
  if (!stored) return null;

  try {
    const data: ConfirmData = JSON.parse(stored);

    // Verify transaction ID matches
    if (data.transactionId !== transactionId) {
      return null;
    }

    // Check if data is stale
    if (Date.now() - data.storedAt > MAX_AGE_MS) {
      clearConfirmData();
      return null;
    }

    return data;
  } catch {
    return null;
  }
}

export function clearConfirmData(): void {
  localStorage.removeItem(STORAGE_KEY);
}
```
  </action>
  <verify>File exists with storeConfirmData, getConfirmData, clearConfirmData exports.</verify>
  <done>Confirm data persists across payment redirect with 30-min expiry.</done>
</task>

<task type="auto">
  <name>Task 2: Update init polling page to store confirm data before redirect</name>
  <files>client/src/routes/init/$transactionId/$messageId.tsx</files>
  <action>
Modify init polling page to store confirm data before payment redirect:

1. Add import:
   ```typescript
   import { storeConfirmData } from "@/lib/confirm-data";
   ```

2. In the component, after detecting paymentUrl but BEFORE auto-redirect, store confirm data.

   The init page has access to:
   - transactionId, messageId from params
   - data from getInitResults (provider, item, quote, xinput, payments)

   Need to fetch select results to get bppId, bppUri (or pass from previous context).

   Actually, simpler approach: Add a query for select results OR use data already available.

   Looking at the init page - it doesn't have bppId/bppUri directly. But we can get it from
   the select results using the same transactionId.

3. Add select results query (refetch on mount only):
   ```typescript
   const { data: selectData } = trpc.results.getSelectResults.useQuery(
     { transactionId, messageId: "" }, // messageId not needed for select
     { enabled: !!paymentUrl } // Only fetch when payment URL available
   );
   ```

   Wait - select results need messageId. We don't have select's messageId here.

   Better approach: Store bppId/bppUri in init entry and return in init results.
   But that requires backend changes.

   Simplest approach: Pass bppId/bppUri through URL params or get from init response context.

   Actually, the init response context contains bpp_id and bpp_uri. Let's check if init results
   returns the full context or we need to add it.

   Looking at init-store.ts: InitResult doesn't include bppId/bppUri.

   CLEANEST FIX: Modify init-store.ts to include bppId/bppUri in InitResult (they're in InitEntry).

   Then in init page, when we have paymentUrl:
   ```typescript
   useEffect(() => {
     if (paymentUrl && data?.bppId && data?.bppUri) {
       // Store data for confirm after payment
       storeConfirmData({
         transactionId,
         bppId: data.bppId,
         bppUri: data.bppUri,
         providerId: data.providerId || "",
         itemId: data.itemId || "",
         parentItemId: data.item?.parent_item_id || data.itemId || "",
         xinputFormId: data.xinput?.form?.id || "",
         submissionId: "", // We need this from KYC form - but it's in init request, not response
         // This is a problem - submissionId is in the init REQUEST, not response
       });
     }
   }, [paymentUrl, data]);
   ```

   The submissionId problem: It's generated in quote page and sent with init request.
   The init response doesn't return it.

   TWO OPTIONS:
   A) Store confirm data in quote page BEFORE calling init (before we know if init succeeds)
   B) Add submissionId to init entry and return in results

   Option A is simpler for this plan - store in quote page when init mutation succeeds.

4. Actually, let's store in QUOTE PAGE when init mutation succeeds (onSuccess):
   - Quote page has all the data needed (KYC form data, submissionId, addOns, etc.)
   - Store confirm data in onSuccess callback before navigating to init polling

Update quote page instead:
   ```typescript
   const initMutation = trpc.gateway.init.useMutation({
     onSuccess: (result) => {
       // Store confirm data before navigating to init polling
       storeConfirmData({
         transactionId,
         bppId: data?.bppId || "",
         bppUri: data?.bppUri || "",
         providerId: data?.providerId || "",
         itemId: data?.itemId || "",
         parentItemId: data?.item?.parent_item_id || data?.itemId || "",
         xinputFormId: data?.xinput?.form?.id || "",
         submissionId, // From KYC form submission
         addOns: selectedAddOns.map(id => ({ id, quantity: 1 })),
         customerName: `${formData.firstName} ${formData.lastName}`,
         customerEmail: formData.email,
         customerPhone: formData.phone,
         quoteId: data?.quote?.id || "",
         amount: data?.quote?.price?.value || "0",
         quoteBreakup: data?.quote?.breakup,
       });

       navigate({ to: "/init/$transactionId/$messageId", params: { ... } });
     },
   });
   ```

   But wait - we don't have formData in onSuccess. We have it in handleKYCSubmit.

   Best approach: Store confirm data in handleKYCSubmit, right before calling init mutation.
  </action>
  <verify>Quote page stores confirm data before init mutation. Data includes all fields needed for confirm request.</verify>
  <done>Confirm data stored before payment redirect.</done>
</task>

<task type="auto">
  <name>Task 3: Create payment callback page</name>
  <files>client/src/routes/payment-callback/$transactionId.tsx</files>
  <action>
Create client/src/routes/payment-callback/$transactionId.tsx:

```typescript
import { createFileRoute, useNavigate, Link } from "@tanstack/react-router";
import { AlertCircle, ArrowLeft, ExternalLink, Loader2, RefreshCw } from "lucide-react";
import { useState, useEffect } from "react";
import { Button } from "@/components/ui/button";
import { Card, CardContent } from "@/components/ui/card";
import { trpc } from "@/trpc/client";
import { getConfirmData, clearConfirmData } from "@/lib/confirm-data";

export const Route = createFileRoute("/payment-callback/$transactionId")({
  component: PaymentCallbackPage,
});

type Stage = "loading" | "confirming" | "polling" | "success" | "not-paid" | "error";

function PaymentCallbackPage() {
  const { transactionId } = Route.useParams();
  const navigate = useNavigate();

  const [stage, setStage] = useState<Stage>("loading");
  const [orderId, setOrderId] = useState<string | null>(null);
  const [errorMessage, setErrorMessage] = useState<string>("");
  const [pollStartTime] = useState(() => Date.now());

  // Load confirm data on mount
  const confirmData = getConfirmData(transactionId);

  // Confirm mutation with 3 retries (per CONTEXT.md)
  const confirmMutation = trpc.gateway.confirm.useMutation({
    retry: 3,
    retryDelay: (attempt) => Math.min(1000 * Math.pow(2, attempt), 10000),
    onSuccess: (result) => {
      // Need to poll confirm results for orderId
      setStage("polling");
    },
    onError: (error) => {
      setErrorMessage(error.message);
      setStage("error");
    },
  });

  // Poll confirm results to get orderId from on_confirm
  const { data: confirmResult } = trpc.results.getConfirmResults.useQuery(
    {
      transactionId,
      messageId: confirmMutation.data?.messageId || ""
    },
    {
      enabled: stage === "polling" && !!confirmMutation.data?.messageId,
      refetchInterval: (query) => {
        if (query.state.data?.hasResponse) return false;
        if (query.state.data?.error) return false;
        // 60 second timeout for confirm response
        if (Date.now() - pollStartTime > 60000) return false;
        return 2000;
      },
    }
  );

  // When confirm response received, start status polling
  useEffect(() => {
    if (confirmResult?.hasResponse && confirmResult?.orderId) {
      setOrderId(confirmResult.orderId);
      // Trigger status request
      statusMutation.mutate({
        transactionId,
        orderId: confirmResult.orderId,
        bppId: confirmData?.bppId || "",
        bppUri: confirmData?.bppUri || "",
      });
    }
  }, [confirmResult]);

  // Status mutation
  const statusMutation = trpc.gateway.status.useMutation({
    onError: (error) => {
      setErrorMessage(error.message);
      setStage("error");
    },
  });

  // Poll status results (2 minute timeout per CONTEXT.md)
  const { data: statusResult, refetch: refetchStatus } = trpc.results.getStatusResults.useQuery(
    { orderId: orderId || "" },
    {
      enabled: !!orderId && !!statusMutation.data,
      refetchInterval: (query) => {
        const elapsed = Date.now() - pollStartTime;
        // 2 minute timeout per CONTEXT.md
        if (elapsed > 120000) return false;
        // Stop on PAID
        if (query.state.data?.paymentStatus === "PAID") return false;
        // Stop on policy document
        if (query.state.data?.policyDocument?.url) return false;
        // Stop on error
        if (query.state.data?.error) return false;
        return 3000; // Poll every 3s per RESEARCH.md
      },
    }
  );

  // Handle status result changes
  useEffect(() => {
    if (statusResult?.paymentStatus === "PAID" || statusResult?.policyDocument?.url) {
      clearConfirmData();
      navigate({
        to: "/policy-success/$orderId",
        params: { orderId: orderId! }
      });
    } else if (statusResult?.paymentStatus === "NOT-PAID" && statusResult?.hasResponse) {
      setStage("not-paid");
    }
  }, [statusResult, orderId]);

  // Trigger confirm on mount if we have data
  useEffect(() => {
    if (!confirmData) {
      setErrorMessage("Payment session expired or invalid. Please start over.");
      setStage("error");
      return;
    }

    setStage("confirming");
    confirmMutation.mutate({
      ...confirmData,
      messageId: undefined, // Let server generate new one
    });
  }, []);

  // Loading state
  if (stage === "loading") {
    return (
      <div className="min-h-screen bg-background flex items-center justify-center">
        <Loader2 className="h-12 w-12 animate-spin text-primary" />
      </div>
    );
  }

  // Confirming state
  if (stage === "confirming" || (stage === "polling" && !orderId)) {
    return (
      <div className="min-h-screen bg-background flex items-center justify-center">
        <div className="text-center space-y-4">
          <Loader2 className="h-12 w-12 animate-spin text-primary mx-auto" />
          <h2 className="text-lg font-semibold">Confirming your payment...</h2>
          <p className="text-sm text-muted-foreground">
            Please wait while we verify your transaction
          </p>
          {confirmMutation.failureCount > 0 && (
            <p className="text-sm text-amber-600">
              Retry {confirmMutation.failureCount}/3
            </p>
          )}
        </div>
      </div>
    );
  }

  // Polling status state
  if (stage === "polling" && orderId) {
    return (
      <div className="min-h-screen bg-background flex items-center justify-center">
        <div className="text-center space-y-4">
          <Loader2 className="h-12 w-12 animate-spin text-primary mx-auto" />
          <h2 className="text-lg font-semibold">Processing your policy...</h2>
          <p className="text-sm text-muted-foreground">
            This may take a moment
          </p>
        </div>
      </div>
    );
  }

  // NOT-PAID state (per CONTEXT.md: show instructions)
  if (stage === "not-paid") {
    return (
      <div className="min-h-screen bg-background">
        <main className="container mx-auto px-4 py-8 max-w-2xl">
          <Card className="border-2 border-amber-500">
            <CardContent className="pt-6">
              <div className="text-center space-y-4">
                <AlertCircle className="h-12 w-12 text-amber-500 mx-auto" />
                <h2 className="text-xl font-bold text-amber-600">
                  Payment Processing
                </h2>
                <p className="text-sm text-muted-foreground">
                  If you completed payment, please wait a moment for it to be verified.
                  <br />
                  Otherwise, please contact support for assistance.
                </p>
                <div className="flex flex-col sm:flex-row gap-3 justify-center pt-4">
                  <Button
                    variant="outline"
                    onClick={() => {
                      // Re-trigger status polling
                      if (orderId) {
                        statusMutation.mutate({
                          transactionId,
                          orderId,
                          bppId: confirmData?.bppId || "",
                          bppUri: confirmData?.bppUri || "",
                        });
                        refetchStatus();
                      }
                    }}
                    className="gap-2"
                  >
                    <RefreshCw className="h-4 w-4" />
                    Check Status
                  </Button>
                  <Button variant="ghost" asChild>
                    <Link to="/">
                      <ArrowLeft className="h-4 w-4 mr-2" />
                      Return Home
                    </Link>
                  </Button>
                </div>
              </div>
            </CardContent>
          </Card>
        </main>
      </div>
    );
  }

  // Error state
  return (
    <div className="min-h-screen bg-background">
      <main className="container mx-auto px-4 py-8 max-w-2xl">
        <Card className="border-2 border-destructive">
          <CardContent className="pt-6">
            <div className="text-center space-y-4">
              <AlertCircle className="h-12 w-12 text-destructive mx-auto" />
              <h2 className="text-xl font-bold text-destructive">
                Payment Error
              </h2>
              <p className="text-sm text-muted-foreground">{errorMessage}</p>
              <div className="flex flex-col sm:flex-row gap-3 justify-center pt-4">
                <Button variant="ghost" asChild>
                  <Link to="/">
                    <ArrowLeft className="h-4 w-4 mr-2" />
                    Return Home
                  </Link>
                </Button>
              </div>
            </div>
          </CardContent>
        </Card>
      </main>
    </div>
  );
}
```

Also update init page to redirect to payment-callback instead of direct payment URL.
Current behavior: User goes to payment URL directly.
Needed: After payment, BPP redirects back to our callback URL.

Actually, the flow is:
1. Init page shows payment URL
2. User clicks/auto-redirects to BPP payment page
3. BPP payment page has a return URL configured
4. After payment, BPP redirects to return URL (our callback page)

The return URL is typically configured in ONDC subscriber registration, pointing to `/payment-callback/{transaction_id}`.

No change needed to init page flow - the BPP handles the redirect.
  </action>
  <verify>
1. Payment callback page compiles
2. Route file exists at client/src/routes/payment-callback/$transactionId.tsx
3. Page handles all states: loading, confirming, polling, not-paid, error
  </verify>
  <done>Payment callback handles return, triggers confirm, polls status, redirects on success.</done>
</task>

</tasks>

<verification>
1. TypeScript compilation: `cd client && pnpm exec tsc --noEmit`
2. confirm-data.ts exports storage functions
3. Payment callback route exists and handles all states
4. Quote page stores confirm data before init
</verification>

<success_criteria>
- Confirm data persists in localStorage before payment redirect
- Payment callback page triggers confirm mutation on mount
- Status polling has 2-minute timeout with 3-second intervals
- NOT-PAID state shows helpful instructions per CONTEXT.md
- Success redirects to policy-success page
</success_criteria>

<output>
After completion, create `.planning/phases/04-confirm-status/04-03-SUMMARY.md`
</output>
