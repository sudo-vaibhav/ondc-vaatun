---
phase: 03-async-callback-correlation
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - server/src/trpc/routers/gateway.ts
autonomous: true

must_haves:
  truths:
    - "gateway.search stores traceparent in Redis when creating a search entry"
    - "gateway.onSearch retrieves traceparent from search entry and creates a linked span"
    - "on_search span has ondc.transaction_id, ondc.bpp_id, ondc.bpp_uri, ondc.action attributes"
    - "on_search span has SpanLink referencing the original ondc.search span"
    - "Missing trace context logs a console.warn but does not fail the callback"
    - "BPP error/NACK responses set SpanStatusCode.ERROR on the callback span"
    - "Multiple BPP callbacks each create their own sibling span, all linked to the same original"
  artifacts:
    - path: "server/src/trpc/routers/gateway.ts"
      provides: "Trace context storage in search, trace restoration in onSearch"
      contains: "serializeTraceContext"
  key_links:
    - from: "server/src/trpc/routers/gateway.ts"
      to: "server/src/lib/trace-context-store.ts"
      via: "import serializeTraceContext, restoreTraceContext, createLinkedSpanOptions"
      pattern: "import.*trace-context-store"
    - from: "server/src/trpc/routers/gateway.ts"
      to: "server/src/lib/search-store.ts"
      via: "createSearchEntry with traceparent parameter"
      pattern: "createSearchEntry\\(.*traceparent"
---

<objective>
Wire trace context storage into gateway.search and trace restoration into gateway.onSearch so callbacks link back to their originating request traces.

Purpose: Complete the async callback correlation pattern for the search/on_search flow. After this plan, searching by transactionId in SigNoz shows the full trace waterfall — the originating search request and all BPP callback responses linked via span links.

Output: Modified `gateway.ts` with trace context serialization in search and linked span creation in onSearch.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-async-callback-correlation/03-RESEARCH.md
@.planning/phases/03-async-callback-correlation/CONTEXT.md
@.planning/phases/03-async-callback-correlation/03-01-SUMMARY.md
@server/src/trpc/routers/gateway.ts
@server/src/lib/trace-context-store.ts
@server/src/lib/search-store.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Store trace context in gateway.search</name>
  <files>server/src/trpc/routers/gateway.ts</files>
  <action>
Modify the `search` mutation in `gateway.ts`:

1. **Add import** at the top of the file:
   ```
   import { serializeTraceContext } from "../../lib/trace-context-store";
   ```

2. **Serialize and store trace context** inside the `tracer.startActiveSpan("ondc.search", ...)` callback, AFTER setting span attributes and BEFORE `createSearchEntry()`:
   - Call `const traceparent = serializeTraceContext();` — this captures the current active span's trace context
   - The call is INSIDE startActiveSpan so the active span context is available

3. **Pass traceparent to createSearchEntry():**
   - Change the existing `createSearchEntry(kv, transactionId, messageId, input.categoryCode)` call to include traceparent as the last argument:
   ```
   await createSearchEntry(kv, transactionId, messageId, input.categoryCode, undefined, traceparent);
   ```
   - Note: pass `undefined` for the `ttl` parameter to use its default value, then `traceparent` as the 6th argument

This is a minimal change — only 2 new lines plus modifying 1 existing line. The search flow continues to work exactly as before, but now also stores trace context for callback correlation.
  </action>
  <verify>
Run `npx tsc --noEmit` from server directory. Verify the import is present and createSearchEntry call includes traceparent.
  </verify>
  <done>
gateway.search serializes current trace context via serializeTraceContext() and passes it to createSearchEntry(). Trace context is stored atomically in the same Redis write as the search entry.
  </done>
</task>

<task type="auto">
  <name>Task 2: Restore trace context and create linked span in gateway.onSearch</name>
  <files>server/src/trpc/routers/gateway.ts</files>
  <action>
Modify the `onSearch` mutation in `gateway.ts`:

1. **Add imports** at the top of the file (extend the existing trace-context-store import):
   ```
   import { serializeTraceContext, restoreTraceContext, createLinkedSpanOptions } from "../../lib/trace-context-store";
   ```
   Also add to the existing `@opentelemetry/api` import:
   ```
   import { SpanKind, SpanStatusCode, trace } from "@opentelemetry/api";
   ```
   (Add `SpanKind` to the existing import)

2. **Add import for getSearchEntry** (if not already imported):
   ```
   import { addSearchResponse, createSearchEntry, getSearchEntry } from "../../lib/search-store";
   ```

3. **Rewrite the onSearch mutation body** to wrap the entire handler in a linked span:

   ```typescript
   .mutation(async ({ ctx, input }) => {
     const { kv } = ctx;

     console.log(
       "\n\n[on_search] Request Body:\n\n",
       JSON.stringify(input, null, "\t"),
     );

     const transactionId = input.context?.transaction_id;

     if (!transactionId) {
       console.warn("[on_search] No transaction_id found in context");
       return { message: { ack: { status: "ACK" as const } } };
     }

     // Retrieve stored trace context from search entry
     const entry = await getSearchEntry(kv, transactionId);
     const originalSpanContext = restoreTraceContext(entry?.traceparent);

     if (!entry?.traceparent) {
       console.warn("[on_search] No trace context found for transaction:", transactionId);
     }

     // Create callback span with link to original search span
     const spanOptions = createLinkedSpanOptions(originalSpanContext, {
       kind: SpanKind.SERVER,
       attributes: {
         "ondc.transaction_id": transactionId,
         "ondc.action": "on_search",
         "ondc.bpp_id": input.context?.bpp_id || "unknown",
         "ondc.bpp_uri": input.context?.bpp_uri || "unknown",
       },
     });

     return tracer.startActiveSpan("ondc.on_search", spanOptions, async (span) => {
       try {
         await addSearchResponse(
           kv,
           transactionId,
           input as Parameters<typeof addSearchResponse>[2],
         );

         // NACK/error responses from BPP set ERROR status (CONTEXT.md decision 2)
         if (input.error) {
           span.setStatus({
             code: SpanStatusCode.ERROR,
             message: `BPP error: ${input.error.code || "unknown"} - ${input.error.message || "no message"}`,
           });
         } else {
           span.setStatus({ code: SpanStatusCode.OK });
         }

         return { message: { ack: { status: "ACK" as const } } };
       } catch (error) {
         span.recordException(error as Error);
         span.setStatus({
           code: SpanStatusCode.ERROR,
           message: (error as Error).message,
         });
         throw error;
       } finally {
         span.end();
       }
     });
   }),
   ```

Key design decisions applied:
- **Span link (not parent-child)**: Uses createLinkedSpanOptions which sets links array — the original span has ended by callback time
- **BPP identity**: Tags span with `ondc.bpp_id` and `ondc.bpp_uri` from callback context (CONTEXT.md decision 2)
- **NACK as ERROR**: BPP error responses set SpanStatusCode.ERROR (CONTEXT.md decision 2)
- **Missing context**: Logs console.warn but continues processing (CONTEXT.md decision 3)
- **Multiple BPPs**: Each callback creates its own span — they're parallel siblings in the trace waterfall
  </action>
  <verify>
Run `npx tsc --noEmit` from server directory to verify compilation. Verify onSearch uses tracer.startActiveSpan with span links. Verify SpanKind.SERVER is used. Verify error handling sets SpanStatusCode.ERROR.
  </verify>
  <done>
gateway.onSearch retrieves stored trace context, creates a linked span with BPP identity attributes, handles NACK/errors as ERROR status, and gracefully handles missing trace context. Multiple BPP callbacks each create their own linked span as siblings in the trace waterfall.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors from server directory
2. gateway.search calls serializeTraceContext() and passes result to createSearchEntry()
3. gateway.onSearch calls getSearchEntry() to retrieve traceparent
4. gateway.onSearch calls restoreTraceContext() and createLinkedSpanOptions()
5. gateway.onSearch creates span "ondc.on_search" with SpanKind.SERVER
6. on_search span has attributes: ondc.transaction_id, ondc.action, ondc.bpp_id, ondc.bpp_uri
7. BPP errors set SpanStatusCode.ERROR on the span
8. Missing traceparent logs a warning but does not crash the handler
</verification>

<success_criteria>
- Search requests store W3C traceparent string in Redis alongside search entry metadata
- on_search callbacks retrieve traceparent and create linked spans in the same trace tree
- Each BPP callback creates its own span with BPP identity attributes
- BPP NACK/error responses properly set ERROR span status
- Missing trace context is handled gracefully (orphan trace, console.warn)
- All existing functionality preserved — callbacks still ACK, responses still stored
</success_criteria>

<output>
After completion, create `.planning/phases/03-async-callback-correlation/03-02-SUMMARY.md`
</output>
