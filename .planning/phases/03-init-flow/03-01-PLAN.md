---
phase: 03-init-flow
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - server/src/infra/key-value/redis/key-formatter.ts
  - server/src/lib/init-store.ts
  - server/src/trpc/routers/gateway.ts
  - server/src/trpc/routers/results.ts
autonomous: true

must_haves:
  truths:
    - "init endpoint accepts KYC data and sends Beckn-compliant init payload to BPP"
    - "on_init callback stores BPP response in Redis with payment link or next form info"
    - "getInitResults returns init state for frontend polling"
  artifacts:
    - path: "server/src/lib/init-store.ts"
      provides: "Init entry and response storage operations"
      exports: ["createInitEntry", "addInitResponse", "getInitEntry", "getInitResponse", "getInitResult"]
    - path: "server/src/infra/key-value/redis/key-formatter.ts"
      provides: "Init key formatting functions"
      contains: "init:"
    - path: "server/src/trpc/routers/gateway.ts"
      provides: "init and onInit procedures"
      contains: "init:"
    - path: "server/src/trpc/routers/results.ts"
      provides: "getInitResults procedure"
      contains: "getInitResults"
  key_links:
    - from: "server/src/trpc/routers/gateway.ts"
      to: "server/src/lib/init-store.ts"
      via: "createInitEntry, addInitResponse"
      pattern: "import.*init-store"
    - from: "server/src/trpc/routers/results.ts"
      to: "server/src/lib/init-store.ts"
      via: "getInitResult"
      pattern: "import.*init-store"
---

<objective>
Create backend infrastructure for init/on_init flow following the established select flow pattern.

Purpose: Enable KYC form submission to BPP and capture payment link response.
Output: Working init/onInit tRPC procedures with Redis-backed state storage.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-init-flow/03-RESEARCH.md

# Existing patterns to follow exactly
@server/src/lib/select-store.ts
@server/src/trpc/routers/gateway.ts
@server/src/trpc/routers/results.ts
@server/src/infra/key-value/redis/key-formatter.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add init key formatter and create init-store.ts</name>
  <files>
    server/src/infra/key-value/redis/key-formatter.ts
    server/src/lib/init-store.ts
  </files>
  <action>
1. Update key-formatter.ts:
   - Add INIT to KEY_PREFIXES constant
   - Add initKey(transactionId, messageId) function (same pattern as selectKey)
   - Add initChannel(transactionId, messageId) function (same pattern as selectChannel)
   - Export init and initChannel in keyFormatter object

2. Create init-store.ts by copying select-store.ts pattern:
   - Define OnInitContext interface (same as OnSelectContext)
   - Define InitItem interface with xinput.form (url, id, mime_type) and payments support
   - Define OnInitResponse interface with message.order.payments[] containing url field
   - Define InitEntry interface: transactionId, messageId, itemId, providerId, bppId, bppUri, initTimestamp, createdAt
   - Define InitResult interface: found, transactionId, messageId, hasResponse, quote, provider, item, xinput, payments, error
   - Implement createInitEntry() - stores entry with 10 minute TTL
   - Implement addInitResponse() - stores response and publishes to channel
   - Implement getInitEntry(), getInitResponse() - retrieval functions
   - Implement getInitResult() - combines entry and response for frontend

Key difference from select-store: InitResult includes payments[] array to expose payment.url for redirect.
  </action>
  <verify>
    - `grep -r "init:" server/src/infra/key-value/redis/key-formatter.ts` returns matches
    - File server/src/lib/init-store.ts exists and exports createInitEntry, addInitResponse, getInitResult
    - `pnpm exec tsc --noEmit -p server` passes
  </verify>
  <done>
    - init key formatter functions added to key-formatter.ts
    - init-store.ts created with all store operations
    - Types compile without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Add init and onInit procedures to gateway router</name>
  <files>server/src/trpc/routers/gateway.ts</files>
  <action>
Add two new procedures to gatewayRouter:

1. init procedure:
   Input schema:
   - transactionId: z.uuid()
   - bppId: z.string()
   - bppUri: z.url()
   - providerId: z.string()
   - itemId: z.string()
   - parentItemId: z.string()
   - xinputFormId: z.string()
   - submissionId: z.string()
   - addOns: z.array(z.object({ id: z.string(), quantity: z.number().int().positive() })).optional()
   - customerName: z.string()
   - customerEmail: z.string().email()
   - customerPhone: z.string()
   - amount: z.string()

   Mutation logic:
   - Generate messageId using uuidv7()
   - Create init entry via createInitEntry()
   - Build payload with:
     - context.action = "init"
     - context.ttl = "P24H" (24 hours, not 30 seconds like select)
     - message.order.items[0].xinput.form.id and form_response with submission_id and status "SUCCESS"
     - message.order.fulfillments[0].customer with person.name and contact.email/phone (phone prefixed with +91-)
     - message.order.payments[0] with collected_by: "BPP", status: "NOT-PAID", type: "PRE-FULFILLMENT", params.amount/currency
   - Construct init URL from bppUri + "/init"
   - Send via ondcClient.send()
   - Return response with transactionId and messageId

2. onInit procedure:
   Input schema (same pattern as onSelect):
   - context: z.object({ transaction_id, message_id, bpp_id, bpp_uri }).passthrough().optional()
   - message: z.any().optional()
   - error: z.object({ type, code, message }).passthrough().optional()

   Mutation logic:
   - Log request body
   - Extract transactionId and messageId from context
   - If error, log it
   - If transactionId and messageId, call addInitResponse()
   - Return { message: { ack: { status: "ACK" } } }

Import createInitEntry and addInitResponse from init-store.
  </action>
  <verify>
    - `grep -E "init:|onInit:" server/src/trpc/routers/gateway.ts` shows both procedures
    - `pnpm exec tsc --noEmit -p server` passes
  </verify>
  <done>
    - init procedure sends Beckn-compliant init payload with customer info and form_response
    - onInit procedure stores BPP response in Redis
    - Both procedures compile without type errors
  </done>
</task>

<task type="auto">
  <name>Task 3: Add getInitResults to results router</name>
  <files>server/src/trpc/routers/results.ts</files>
  <action>
Add getInitResults procedure following getSelectResults pattern:

Input schema:
- transactionId: z.string()
- messageId: z.string()

Query logic:
- Call getInitResult(kv, transactionId, messageId)
- If not found, return { found: false, transactionId, messageId, hasResponse: false, message: "No init entry found..." }
- Otherwise return the result (includes payments array with payment URLs)

Import getInitResult from init-store.
  </action>
  <verify>
    - `grep "getInitResults" server/src/trpc/routers/results.ts` returns match
    - `pnpm exec tsc --noEmit -p server` passes
    - Dev server starts: `pnpm dev:server` (then Ctrl+C after startup)
  </verify>
  <done>
    - getInitResults procedure returns init state for polling
    - Frontend can poll for on_init response arrival
    - Server compiles and starts without errors
  </done>
</task>

</tasks>

<verification>
1. TypeScript compilation passes: `pnpm exec tsc --noEmit -p server`
2. Server starts without errors: `pnpm dev:server` (verify startup, then stop)
3. All three store operations exported: `grep -E "export (async function|function)" server/src/lib/init-store.ts`
4. Key formatter updated: `grep "init" server/src/infra/key-value/redis/key-formatter.ts`
</verification>

<success_criteria>
- init-store.ts exists with same pattern as select-store.ts
- gateway.ts has init and onInit procedures
- results.ts has getInitResults procedure
- All TypeScript compiles without errors
- Server starts successfully
</success_criteria>

<output>
After completion, create `.planning/phases/03-init-flow/03-01-SUMMARY.md`
</output>
