---
phase: 01-select-flow
plan: 03
type: execute
wave: 3
depends_on: ["01-02"]
files_modified:
  - tests/api/gateway.spec.ts
  - tests/api/polling.spec.ts
  - server/public/openapi.json

autonomous: false

must_haves:
  truths:
    - "E2E test verifies select endpoint returns messageId"
    - "E2E test verifies on_select callback stores response"
    - "E2E test verifies getSelectResults returns quote data"
    - "OpenAPI spec documents select flow endpoints"
  artifacts:
    - path: "tests/api/gateway.spec.ts"
      provides: "E2E tests for select/on_select"
      contains: "select"
    - path: "tests/api/polling.spec.ts"
      provides: "E2E tests for select results polling"
      contains: "getSelectResults"
    - path: "server/public/openapi.json"
      provides: "OpenAPI documentation for select endpoints"
      contains: "on_select"
  key_links:
    - from: "tests/api/gateway.spec.ts"
      to: "gateway.select"
      via: "POST /api/trpc/gateway.select"
      pattern: "gateway\\.select"
    - from: "tests/api/polling.spec.ts"
      to: "results.getSelectResults"
      via: "GET /api/trpc/results.getSelectResults"
      pattern: "getSelectResults"
---

<objective>
Add E2E tests for the select flow and update OpenAPI documentation. Includes human verification checkpoint for visual UI testing.

Purpose: Ensure the select flow is tested and documented per project requirements (TEST-01, API docs requirement from CLAUDE.md).
Output: Comprehensive E2E tests for select flow, updated OpenAPI spec.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-select-flow/CONTEXT.md

@tests/api/gateway.spec.ts
@tests/api/polling.spec.ts
@server/public/openapi.json
@CLAUDE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add select flow E2E tests to gateway.spec.ts</name>
  <files>tests/api/gateway.spec.ts</files>
  <action>
Add tests to `tests/api/gateway.spec.ts` for the select flow:

1. Test: "gateway.select - sends select request and returns messageId"
```typescript
test("gateway.select - sends select request and returns messageId", async ({ request }) => {
  // First, perform a search to get valid BPP info
  const searchResponse = await request.post("/api/trpc/gateway.search", {
    data: { json: { categoryCode: "HEALTH_INSURANCE" } },
  });
  expect([200, 502, 503]).toContain(searchResponse.status());

  if (searchResponse.status() !== 200) {
    console.log("Gateway unavailable, skipping select test");
    return;
  }

  const searchResult = await searchResponse.json();
  const transactionId = searchResult.result?.data?.json?.transactionId;
  expect(transactionId).toBeDefined();

  // Wait for search results
  await new Promise(resolve => setTimeout(resolve, 3000));

  // Get search results to find a BPP
  const resultsResponse = await request.get(
    `/api/trpc/results.getSearchResults?input=${encodeURIComponent(JSON.stringify({ json: { transactionId } }))}`
  );

  const results = await resultsResponse.json();
  const responses = results.result?.data?.json?.responses || [];

  if (responses.length === 0) {
    console.log("No search responses, skipping select test");
    return;
  }

  // Find first valid response with items
  const validResponse = responses.find(r =>
    r.message?.catalog?.providers?.[0]?.items?.length > 0
  );

  if (!validResponse) {
    console.log("No items in search results, skipping select test");
    return;
  }

  const provider = validResponse.message.catalog.providers[0];
  const item = provider.items[0];

  // Call select
  const selectResponse = await request.post("/api/trpc/gateway.select", {
    data: {
      json: {
        transactionId,
        bppId: validResponse.context.bpp_id,
        bppUri: validResponse.context.bpp_uri,
        providerId: provider.id,
        itemId: item.id,
        parentItemId: item.parent_item_id || item.id,
      },
    },
  });

  expect([200, 502, 503]).toContain(selectResponse.status());

  if (selectResponse.status() === 200) {
    const selectResult = await selectResponse.json();
    expect(selectResult.result?.data?.json?.messageId).toBeDefined();
    expect(selectResult.result?.data?.json?.transactionId).toBe(transactionId);
  }
});
```

2. Test: "gateway.onSelect - handles callback and stores response"
```typescript
test("gateway.onSelect - handles callback and stores response", async ({ request }) => {
  const mockOnSelectPayload = {
    context: {
      domain: "ONDC:FIS13",
      action: "on_select",
      bap_id: "test-bap",
      bap_uri: "https://test-bap.com",
      bpp_id: "test-bpp",
      bpp_uri: "https://test-bpp.com",
      transaction_id: crypto.randomUUID(),
      message_id: crypto.randomUUID(),
      timestamp: new Date().toISOString(),
      ttl: "PT30S",
    },
    message: {
      order: {
        provider: { id: "P1", descriptor: { name: "Test Provider" } },
        items: [{ id: "I1", price: { currency: "INR", value: "1000" } }],
        quote: { price: { currency: "INR", value: "1000" }, breakup: [] },
      },
    },
  };

  const response = await request.post("/api/trpc/gateway.onSelect", {
    data: { json: mockOnSelectPayload },
  });

  expect(response.status()).toBe(200);
  const result = await response.json();
  expect(result.result?.data?.json?.message?.ack?.status).toBe("ACK");
});
```

IMPORTANT: Per CLAUDE.md, never use test.skip() for gateway errors. Accept 502/503 as valid responses.
  </action>
  <verify>
- Tests added to `tests/api/gateway.spec.ts`
- Tests use `expect([200, 502, 503]).toContain()` pattern for gateway calls
- Run specific test: `pnpm test:e2e -- tests/api/gateway.spec.ts --timeout=60000`
  </verify>
  <done>E2E tests verify select and on_select endpoints</done>
</task>

<task type="auto">
  <name>Task 2: Add select results polling tests</name>
  <files>tests/api/polling.spec.ts</files>
  <action>
Add tests to `tests/api/polling.spec.ts` for select results polling:

1. Test: "results.getSelectResults - returns pending when no response"
```typescript
test("results.getSelectResults - returns pending when no response", async ({ request }) => {
  const transactionId = crypto.randomUUID();
  const messageId = crypto.randomUUID();

  const response = await request.get(
    `/api/trpc/results.getSelectResults?input=${encodeURIComponent(
      JSON.stringify({ json: { transactionId, messageId } })
    )}`
  );

  expect(response.status()).toBe(200);
  const result = await response.json();
  expect(result.result?.data?.json?.found).toBe(false);
  expect(result.result?.data?.json?.hasResponse).toBe(false);
});
```

2. Test: "results.getSelectResults - returns quote after on_select callback"
```typescript
test("results.getSelectResults - returns quote after on_select callback", async ({ request }) => {
  const transactionId = crypto.randomUUID();
  const messageId = crypto.randomUUID();

  // Simulate on_select callback first
  const onSelectPayload = {
    context: {
      domain: "ONDC:FIS13",
      action: "on_select",
      bap_id: "test-bap",
      bap_uri: "https://test-bap.com",
      bpp_id: "test-bpp",
      bpp_uri: "https://test-bpp.com",
      transaction_id: transactionId,
      message_id: messageId,
      timestamp: new Date().toISOString(),
      ttl: "PT30S",
    },
    message: {
      order: {
        provider: { id: "P1", descriptor: { name: "Test Insurance Co" } },
        items: [{
          id: "I1",
          descriptor: { name: "Health Plan Basic" },
          price: { currency: "INR", value: "5000" },
          tags: [{
            descriptor: { code: "GENERAL_INFO" },
            list: [
              { descriptor: { code: "COVERAGE_AMOUNT" }, value: "500000" },
              { descriptor: { code: "CO_PAYMENT" }, value: "20" },
            ],
          }],
        }],
        quote: {
          price: { currency: "INR", value: "5500" },
          breakup: [
            { title: "BASE_PRICE", price: { currency: "INR", value: "5000" } },
            { title: "TAX", price: { currency: "INR", value: "500" } },
          ],
          ttl: "P15D",
        },
      },
    },
  };

  await request.post("/api/trpc/gateway.onSelect", {
    data: { json: onSelectPayload },
  });

  // Now poll for results
  const response = await request.get(
    `/api/trpc/results.getSelectResults?input=${encodeURIComponent(
      JSON.stringify({ json: { transactionId, messageId } })
    )}`
  );

  expect(response.status()).toBe(200);
  const result = await response.json();
  const data = result.result?.data?.json;

  expect(data?.found).toBe(true);
  expect(data?.hasResponse).toBe(true);
  expect(data?.quote?.price?.value).toBe("5500");
  expect(data?.provider?.descriptor?.name).toBe("Test Insurance Co");
});
```
  </action>
  <verify>
- Tests added to `tests/api/polling.spec.ts`
- Run specific test: `pnpm test:e2e -- tests/api/polling.spec.ts --timeout=60000`
  </verify>
  <done>E2E tests verify select results polling behavior</done>
</task>

<task type="auto">
  <name>Task 3: Update OpenAPI spec for select endpoints</name>
  <files>server/public/openapi.json</files>
  <action>
Update `server/public/openapi.json` to document the select flow endpoints.

Add to paths:
1. `/api/trpc/gateway.select` - POST
   - Summary: "Send select request to BPP"
   - Request body: transactionId, bppId, bppUri, providerId, itemId, parentItemId, addOns (optional)
   - Response: ACK with transactionId and messageId

2. `/api/trpc/gateway.onSelect` - POST
   - Summary: "Receive on_select callback from BPP"
   - Request body: ONDC on_select payload structure
   - Response: ACK

3. `/api/trpc/results.getSelectResults` - GET
   - Summary: "Poll for select results"
   - Query params: transactionId, messageId
   - Response: SelectResult with quote, provider, item data

Use existing patterns from search endpoints in the file. Include:
- operationId
- tags: ["Gateway"] or ["Results"]
- request/response schemas

Reference ONDC FIS13 spec for accurate payload structures.
  </action>
  <verify>
- OpenAPI spec updated
- Start dev server and visit http://localhost:4822/api/reference
- Verify select endpoints appear in documentation
  </verify>
  <done>OpenAPI documentation updated with select flow endpoints</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete select flow implementation:
1. Quote page with polling, loading states, error handling
2. Coverage details, add-on toggles, collapsible T&C
3. E2E tests for backend endpoints
4. OpenAPI documentation
  </what-built>
  <how-to-verify>
1. Start dev servers: `pnpm dev`
2. Navigate to http://localhost:4823
3. Click "Health Insurance" to start a search
4. Wait for search results to load
5. Click "Get Health Quote" on any plan
6. Verify:
   - Loading state appears (spinner with "Fetching your personalized quote...")
   - Quote page shows when response arrives OR error state if BPP fails
   - If quote loads: premium prominent at top, coverage grid visible
   - Add-on toggles work (if add-ons present)
   - Terms section expands/collapses
   - Back button returns to search results
7. Visit http://localhost:4822/api/reference
8. Verify select endpoints documented
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues to fix</resume-signal>
</task>

</tasks>

<verification>
1. E2E tests pass: `pnpm test:e2e -- tests/api/gateway.spec.ts tests/api/polling.spec.ts --timeout=60000`
2. OpenAPI spec valid: Check http://localhost:4822/api/reference loads without errors
3. Lint passes: `pnpm lint`
4. Build passes: `pnpm build`
</verification>

<success_criteria>
- gateway.select E2E test verifies messageId returned
- gateway.onSelect E2E test verifies ACK response
- getSelectResults E2E tests verify polling behavior
- OpenAPI spec documents all select endpoints
- Human verification confirms UI works end-to-end
</success_criteria>

<output>
After completion, create `.planning/phases/01-select-flow/01-03-SUMMARY.md`
</output>
